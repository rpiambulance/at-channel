<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utilities/helperFunctions.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utilities/helperFunctions.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//local packages
const {
  app: {
    client: {
      usergroups: {
        users: { list }
      },
      chat: { postEphemeral, update }
    }
  }
} = require("../utilities/bolt.js");

// Note you will need to change this to fit emojis that exist in your workspace
const emojisList = require("./emojis.json");

//globals
const TOKEN = process.env.SLACK_BOT_TOKEN;
const USER_TOKEN = process.env.SLACK_USER_TOKEN;
const MOD_CHANNEL_ID = process.env.MOD_CHANNEL_ID;
const ADMIN_USERGROUP_ID = process.env.ADMIN_USERGROUP_ID;
const MOD_USERGROUP_ID = process.env.MOD_USERGROUP_ID;

/**
 * Query Slack to determine if user has appropriate moderating permissions
 * if not post ephemeral to user saying why they can't approve, otherwise execute appropriate action
 * 
 * @returns {next} - if user has appropriate permissions
 * @returns {postEphemeral} - if user does not have permissions
 */
const isModerator = async ({
  body: {
    user: { id },
    channel: { id: channelId },
    message: { blocks }
  },
  next
}) => {
  const { users: adminUsers } = await list({
    token: USER_TOKEN,
    usergroup: ADMIN_USERGROUP_ID
  });
  if (adminUsers.includes(id)) return next();
  const { users: modUsers } = await list({
    token: USER_TOKEN,
    usergroup: MOD_USERGROUP_ID
  });
  const original_poster = /&lt;@(.*?)[a-zA-Z0-9]{7,10}>/
    .exec(blocks[0].text.text)[0]
    .replace("&lt;@", "")
    .replace(">", "");
  if (modUsers.includes(id) &amp;&amp; id != original_poster) return next();
  if (id == original_poster) {
    return postEphemeral({
      token: TOKEN,
      channel: channelId,
      user: id,
      text:
        ":cry: Sorry! Moderators cannot approve or reject their own requests."
    });
  }
  return postEphemeral({
    token: TOKEN,
    channel: channelId,
    user: id,
    text:
      ":cry: Sorry! You're not a moderator, so you cannot approve or reject these requests."
  });
};

/**
 * updates message in moderation channel based on action chosen
 * 
 * @param {string} status - one of "cancelled", "approved", "approved without at-channel"
 * @param {string} channel_id - slack channel ID such as "CFCP42RL7" (no &lt;#, >)
 * @param {string} text - message to be posted
 * @param {string} user_id - slack user ID (no &lt;@, >)
 * @param {string} ts - timestamp ID of message in moderation channel
 * @param {string} moderator - user ID of moderator initiating action
 */
const updateModMessage = (status, channel_id, text, user_id, ts, moderator) => {
  if (status == "cancelled") {
    update({
      token: TOKEN,
      channel: MOD_CHANNEL_ID,
      ts: ts,
      blocks: [
        {
          type: "section",
          text: {
            type: "mrkdwn",
            text: `:point_right: &lt;@${user_id}>'s at-channel request *has been cancelled*.`
          }
        }
      ]
    });
    return;
  }
  // determine appriate emoji for mod message based on action
  const emoji =
    status == "approved"
      ? ":heavy_check_mark:"
      : status == "approved without at-channel"
      ? ":heavy_minus_sign:"
      : ":x:";
  update({
    token: TOKEN,
    channel: MOD_CHANNEL_ID,
    ts: ts,
    blocks: [
      {
        type: "section",
        text: { type: "mrkdwn", text: `${emoji} The message:` }
      },
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `>>>${text}`
        }
      },
      {
        type: "section",
        text: {
          type: "mrkdwn",
          text: `that &lt;@${user_id}> requested to post in &lt;#${channel_id}> has been *${status}* by &lt;@${moderator}>.`
        }
      }
    ]
  });
};

/**
 * return a random emoji of based on categories. Emoji list in emojis.json 
 * 
 * @param {string} sentiment - one of "happy", "medium", "sad", or ""
 * @returns {string}  ":emoji:" - random emoji based on sentiment from emojis.json.
 */
const randomEmoji = sentiment => {
  let emojis = [];
  switch (sentiment) {
    case "happy":
      emojis = emojisList.happy;
      break;
    case "medium":
      emojis = emojisList.medium;
      break;
    case "sad":
      emojis = emojisList.sad;
      break;
    default:
      emojis.concat(emojisList.happy);
      emojis.concat(emojisList.medium);
      emojis.concat(emojisList.sad);
      break;
  }
  return emojis[Math.floor(Math.random() * emojis.length)];
};

module.exports = { isModerator, updateModMessage, randomEmoji };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#approveMessage">approveMessage</a></li><li><a href="global.html#approveNoAt">approveNoAt</a></li><li><a href="global.html#cancelRequest">cancelRequest</a></li><li><a href="global.html#isModerator">isModerator</a></li><li><a href="global.html#postToChannel">postToChannel</a></li><li><a href="global.html#randomEmoji">randomEmoji</a></li><li><a href="global.html#rejectMessage">rejectMessage</a></li><li><a href="global.html#sendForApproval">sendForApproval</a></li><li><a href="global.html#sendRejectionDm">sendRejectionDm</a></li><li><a href="global.html#slashChannel">slashChannel</a></li><li><a href="global.html#updateModMessage">updateModMessage</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Tue Mar 24 2020 11:55:10 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
